<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Qu·∫£n L√Ω Book C·ªù T∆∞·ªõng V26</title>
    <style>
        :root { --board-bg: #eebf81; --line-color: #5a3a22; --piece-bg: #fdf5e6; --primary: #8b0000; }
        
        * { box-sizing: border-box; margin: 0; padding: 0; font-family: sans-serif; touch-action: manipulation; -webkit-tap-highlight-color: transparent;}
        body { background-color: #f4f4f4; display: flex; flex-direction: column; min-height: 100vh; color: #333; }
        
        header { background: var(--primary); color: white; padding: 15px; display: flex; align-items: center; justify-content: center; font-size: 18px; font-weight: bold; position: sticky; top: 0; z-index: 100; box-shadow: 0 2px 5px rgba(0,0,0,0.2);}
        #btn-back { position: absolute; left: 15px; background: transparent; color: white; border: none; font-size: 20px; cursor: pointer; display: none; padding: 0;}
        
        /* ================= DASHBOARD ================= */
        #dashboard-screen { flex: 1; padding: 20px; display: flex; flex-direction: column; gap: 15px; width: 100%; max-width: 800px; margin: 0 auto; }
        .dashboard-actions { display: flex; gap: 10px; width: 100%; flex-wrap: wrap;}
        .btn-main { flex: 1; min-width: 150px; border: none; padding: 15px 10px; font-size: 14px; font-weight: bold; border-radius: 8px; cursor: pointer; box-shadow: 0 4px 6px rgba(0,0,0,0.1); color: white; transition: 0.2s;}
        .btn-create-book { background: #006633; } .btn-import-book { background: #0055aa; } .btn-sync-pc { background: #5a3a22; display: none; }
        .btn-main:active { transform: scale(0.98); }
        #unsaved-warning { display: none; background: #ffebee; color: #cc0000; padding: 12px; text-align: center; font-weight: bold; border-radius: 5px; border: 1px solid #ffcdd2; font-size: 14px;}
        
        .book-list { display: flex; flex-direction: column; gap: 12px; }
        .book-item { background: white; padding: 15px; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.08); display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 10px;}
        .book-info { flex: 1; min-width: 200px; cursor: pointer; }
        .book-title { font-size: 16px; font-weight: bold; color: #111; margin-bottom: 5px;}
        .book-meta { font-size: 13px; color: #777; }
        .book-actions { display: flex; gap: 8px; flex-wrap: wrap; }
        .btn-sm { padding: 8px 12px; border: none; border-radius: 5px; font-size: 13px; cursor: pointer; font-weight: bold; color: white; transition: 0.2s;}
        .btn-export { background: #28a745; } .btn-edit-name { background: #ff9800; } .btn-delete { background: #cc0000; }
        .btn-sm:active { transform: scale(0.95); }

        /* ================= M√ÄN H√åNH B√ÄN C·ªú ================= */
        #editor-screen { display: none; flex-direction: column; flex: 1; padding-bottom: 30px;}
        #turn-indicator { background: #fff; padding: 10px; text-align: center; font-weight: bold; font-size: 16px; border-bottom: 2px solid #ddd; transition: 0.3s;}
        .red-turn { color: #cc0000; } .black-turn { color: #000000; }
        .check-alert { background-color: #ffeb3b !important; color: #d32f2f !important; }
        .mate-alert { background-color: #d32f2f !important; color: #fff !important; }

        .editor-container { display: flex; flex-direction: column; width: 100%; max-width: 1200px; margin: 0 auto; padding: 10px 15px; gap: 15px; }
        .board-column { width: 100%; max-width: 500px; margin: 0 auto; display: flex; flex-direction: column; gap: 10px; }
        .note-column { width: 100%; display: flex; flex-direction: column; }

        #board-area { width: 100%; position: relative; padding: 10px 6%; user-select: none; -webkit-user-select: none; }
        
        /* FIX: Th√™m margin ƒë·ªÉ d√£n d√£y s·ªë ra xa kh·ªèi qu√¢n c·ªù */
        .coord-row { position: relative; width: 100%; height: 16px; }
        #coord-top { margin-bottom: 22px; }
        #coord-bottom { margin-top: 22px; }
        .coord-row span { position: absolute; transform: translateX(-50%); font-size: 14px; font-weight: bold; color: #8b0000; }
        
        #board { position: relative; width: 100%; aspect-ratio: 8 / 9; background-color: var(--board-bg); border: 2px solid var(--line-color); box-shadow: 0 4px 10px rgba(0,0,0,0.15);}
        #board-svg { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 1; }
        #arrow-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 3; transition: 0.3s;}
        #pieces-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 4; transition: 0.3s;}
        
        .point { position: absolute; width: 11%; aspect-ratio: 1; transform: translate(-50%, -50%); display: flex; justify-content: center; align-items: center; border-radius: 50%; cursor: pointer; transition: top 0.3s, left 0.3s; }
        .piece { width: 90%; height: 90%; border-radius: 50%; background: var(--piece-bg); box-shadow: 1px 2px 4px rgba(0,0,0,0.4); display: flex; justify-content: center; align-items: center; font-size: 1.2rem; font-weight: bold; border: 2px solid #333; pointer-events: none; z-index: 2; position: relative; transition: 0.2s;}
        .red-piece { color: #cc0000; border-color: #cc0000; }
        .black-piece { color: #000; border-color: #000; }
        
        /* HI·ªÜU ·ª®NG T∆Ø∆†NG T√ÅC ƒê∆Ø·ª¢C L√ÄM D·ªäU L·∫†I */
        .selected { box-shadow: 0px 0px 5px 1px #00ff008a; border-color: #00ff008a; }
        .in-check-piece { box-shadow: 0 0 10px 4px #ff0000; border-color: #ff0000; background-color: #ffcccc; }
        
        /* Ch·∫•m tr√≤n n∆∞·ªõc ƒëi c≈© nh·ªè h∆°n v√† nh·∫°t h∆°n (70%) */
        .last-move-dot { position: absolute; width: 18%; height: 18%; background-color: rgba(0, 100, 255, 0.35); border-radius: 50%; pointer-events: none; z-index: 1;}
        /* Vi·ªÅn s√°ng cho qu√¢n c·ªù v·ª´a m·ªõi t·ªõi ƒë√≠ch nh·∫°t h∆°n */
        .last-moved-piece { box-shadow: 0 0 8px 2px rgba(0, 100, 255, 0.4); border-color: rgba(0, 100, 255, 0.6); }
        
        .valid-move-hint { width: 25%; height: 25%; background: rgba(0, 200, 0, 0.4); border-radius: 50%; z-index: 1;}
        .capture-hint { position: absolute; width: 95%; height: 95%; border: 3px solid rgba(220, 53, 69, 0.5); border-radius: 50%; z-index: 5; pointer-events: none; }
        .var-marker { position: absolute; top: -5%; right: -5%; width: 40%; aspect-ratio: 1; color: white; border-radius: 50%; display: flex; justify-content: center; align-items: center; font-size: 0.8rem; font-weight: bold; z-index: 5; box-shadow: 0 0 5px rgba(0,0,0,0.5); border: 1px solid white; pointer-events: none; }

        /* ================= B·ªò ƒêI·ªÄU KHI·ªÇN ================= */
        #controls { display: grid; grid-template-columns: repeat(3, 1fr); gap: 6px; width: 100%; padding: 0 5px; margin-top: 5px;}
        .btn-board { padding: 6px 2px; border: none; border-radius: 6px; cursor: pointer; font-size: 11px; font-weight: bold; display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 2px; box-shadow: 0 1px 3px rgba(0,0,0,0.15); transition: all 0.1s ease;}
        .btn-board span { font-size: 16px; margin-bottom: 2px;}
        .btn-board:active { transform: translateY(2px); box-shadow: 0 0px 1px rgba(0,0,0,0.1);}
        .btn-nav-primary { background: #006633; color: white; }
        .btn-nav-fast { background: #8b0000; color: white; }
        .btn-nav-light { background: #fcfcfc; border: 1px solid #ddd; color: #444; }
        .btn-view { background: #f0f4ff; color: #0055aa; border: 1px solid #cce0ff;}

        /* ================= GHI CH√ö ================= */
        .note-column { width: 100%; display: flex; flex-direction: column; }
        #note-section { background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); display: flex; flex-direction: column; gap: 15px; }
        #move-info { font-weight: bold; color: #8b0000; font-size: 16px; border-bottom: 2px solid #f0f0f0; padding-bottom: 10px;}
        
        #variations { display: flex; gap: 10px; flex-wrap: wrap; }
        .var-btn-group { display: flex; align-items: stretch; border-radius: 6px; border: 1px solid #0044cc; overflow: hidden; }
        .var-btn { background: #e8f0fe; color: #0044cc; font-weight: bold; font-size: 14px; padding: 8px 12px; border: none; cursor: pointer; transition: 0.2s;}
        .var-btn:active { background: #d2e3fc; }
        .var-delete-btn { background: #ffe6e6; color: #cc0000; border: none; border-left: 1px solid #0044cc; padding: 0 12px; font-size: 14px; cursor: pointer; transition: 0.2s;}
        .var-delete-btn:active { background: #ffcccc; }
        .capture-group { border-color: #cc0000 !important; }
        .capture-btn { background: #fce8e8 !important; color: #cc0000 !important; }
        .capture-del { background: #f8d7da !important; color: #721c24 !important; border-left-color: #cc0000 !important; }
        
        #note-view, #note-edit { display: flex; flex-direction: column; gap: 12px;}
        #note-content { padding: 15px; background: #fdfdfd; border: 1px solid #e0e0e0; border-radius: 6px; font-size: 15px; line-height: 1.6; min-height: 80px;}
        #note-input { padding: 15px; border: 2px solid #006633; border-radius: 6px; font-size: 15px; resize: vertical; min-height: 120px; font-family: sans-serif; line-height: 1.6;}
        
        .btn-note { padding: 12px; font-size: 15px; width: 100%; border: none; border-radius: 6px; color: white; font-weight: bold; cursor: pointer;}
        .btn-edit-mode { background: #444; }
        .edit-controls { display: grid; grid-template-columns: 2fr 1fr; gap: 10px; }
        .btn-save { background: #006633; } .btn-cancel { background: #888; }

        @media (min-width: 800px) {
            .editor-container { flex-direction: row; align-items: flex-start; padding: 25px; gap: 30px; }
            .board-column { flex: 0 0 450px; position: sticky; top: 80px; }
            .note-column { flex: 1; min-width: 300px; }
            .piece { font-size: 1.4rem; }
            #controls { display: flex; flex-direction: row; justify-content: space-between; flex-wrap: wrap; gap: 5px;}
            .btn-board { flex: 1; flex-direction: row; padding: 8px 4px; font-size: 12px; white-space: nowrap;}
            .btn-board span { font-size: 14px; margin-bottom: 0; margin-right: 3px;}
        }
        @media (max-width: 400px) {
            .piece { font-size: 1.05rem; }
            .dashboard-actions { flex-direction: column; }
        }
    </style>
</head>
<body>

    <header>
        <button id="btn-back" onclick="showDashboard()">‚¨ÖÔ∏è</button>
        <span id="header-title">Qu·∫£n L√Ω Book</span>
    </header>

    <div id="dashboard-screen">
        <div id="unsaved-warning">‚ö†Ô∏è Ch√∫ √Ω: B·∫°n c√≥ d·ªØ li·ªáu v·ª´a thay ƒë·ªïi nh∆∞ng ch∆∞a ƒë∆∞·ª£c T·∫£i v·ªÅ m√°y.</div>
        <div class="dashboard-actions">
            <button class="btn-main btn-create-book" onclick="createNewBook()">‚ûï T·∫†O M·ªöI</button>
            <button class="btn-main btn-import-book" onclick="document.getElementById('file-upload').click()">üìÇ M·ªû FILE (.json)</button>
            <button class="btn-main btn-sync-pc" id="btn-sync" onclick="setupAutoSync()">üîÑ AUTO-SAVE (PC)</button>
            <input type="file" id="file-upload" accept=".json" style="display: none;" onchange="importBook(event)">
        </div>
        <div id="book-list-container" class="book-list"></div>
    </div>

    <div id="editor-screen">
        <div id="turn-indicator" class="red-turn">üî¥ L∆∞·ª£t ƒëi: ƒê·ªé</div>

        <div class="editor-container">
            <div class="board-column">
                
                <div id="board-area">
                    <div id="coord-top" class="coord-row"></div>
                    
                    <div id="board">
                        <svg id="board-svg" viewBox="0 0 800 900" preserveAspectRatio="none"></svg>
                        <svg id="arrow-layer" viewBox="0 0 800 900" preserveAspectRatio="none">
                            <defs>
                                <marker id="arrowhead" markerWidth="8" markerHeight="6" refX="7" refY="3" orient="auto"><polygon points="0 0, 8 3, 0 6" fill="#0044cc" /></marker>
                                <marker id="arrowhead-red" markerWidth="8" markerHeight="6" refX="7" refY="3" orient="auto"><polygon points="0 0, 8 3, 0 6" fill="#cc0000" /></marker>
                            </defs>
                            <g id="arrows-group"></g>
                        </svg>
                        <div id="pieces-layer"></div>
                    </div>
                    
                    <div id="coord-bottom" class="coord-row"></div>
                </div>

                <div id="controls">
                    <button class="btn-board btn-nav-primary" onclick="goBack()" title="L√πi l·∫°i 1 n∆∞·ªõc"><span>üîô</span> L√πi</button>
                    <button class="btn-board btn-nav-primary" onclick="goNext()" title="Ti·∫øp t·ª•c nh√°nh ch√≠nh"><span>üîú</span> Ti·∫øp</button>
                    <button class="btn-board btn-nav-fast" onclick="goBackToBranch()" title="L√πi nhanh v·ªÅ ng√£ r·∫Ω"><span>‚è™</span> Ng√£ r·∫Ω</button>
                    <button class="btn-board btn-view" onclick="toggleMirror()" title="L·∫≠t g∆∞∆°ng ngang b√†n c·ªù"><span>‚ÜîÔ∏è</span> ƒê·∫£o ngang</button>
                    <button class="btn-board btn-view" onclick="toggleFlip()" title="L·∫≠t ng∆∞·ª£c b√†n c·ªù d·ªçc"><span>‚ÜïÔ∏è</span> ƒê·ªïi b√™n</button>
                    <button class="btn-board btn-nav-light" onclick="resetToRoot()" title="V·ªÅ l·∫°i th·∫ø c·ªù kh·ªüi ƒë·∫ßu"><span>üîÑ</span> V·ªÅ ƒë·∫ßu</button>
                </div>
            </div>

            <div class="note-column">
                <div id="note-section">
                    <div id="move-info">N∆∞·ªõc ƒëi: B·∫Øt ƒë·∫ßu</div>
                    
                    <div id="variations" style="display: none;"></div>
                    
                    <div id="note-view">
                        <div id="note-content"></div>
                        <button class="btn-note btn-edit-mode" onclick="enableEditNote()">üìù Th√™m / S·ª≠a Ghi Ch√∫</button>
                    </div>

                    <div id="note-edit" style="display: none;">
                        <textarea id="note-input" placeholder="Vi·∫øt ghi ch√∫, ph√¢n t√≠ch cho nh√°nh c·ªù n√†y..."></textarea>
                        <div class="edit-controls">
                            <button class="btn-note btn-save" onclick="saveNote()">üíæ L∆∞u</button>
                            <button class="btn-note btn-cancel" onclick="cancelEditNote()">H·ªßy</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const startState = [
            ['r','h','e','a','k','a','e','h','r'], ['.','.','.','.','.','.','.','.','.'], ['.','c','.','.','.','.','.','c','.'],
            ['p','.','p','.','p','.','p','.','p'], ['.','.','.','.','.','.','.','.','.'], ['.','.','.','.','.','.','.','.','.'],
            ['P','.','P','.','P','.','P','.','P'], ['.','C','.','.','.','.','.','C','.'], ['.','.','.','.','.','.','.','.','.'],
            ['R','H','E','A','K','A','E','H','R']
        ];
        
        const pieceVietName = { 'R': 'Xe', 'H': 'M√£', 'E': 'T∆∞·ª£ng', 'A': 'Sƒ©', 'K': 'T∆∞·ªõng', 'C': 'Ph√°o', 'P': 'T·ªët', 'r': 'Xe', 'h': 'M√£', 'e': 'T∆∞·ª£ng', 'a': 'Sƒ©', 'k': 'T∆∞·ªõng', 'c': 'Ph√°o', 'p': 'T·ªët' };
        const pieceMap = { 'R': 'Ëªä', 'H': 'È¶¨', 'E': 'Áõ∏', 'A': '‰ªï', 'K': 'Â∏•', 'C': 'ÁÇÆ', 'P': 'ÂÖµ', 'r': 'Ëªä', 'h': 'È¶¨', 'e': 'Ë±°', 'a': 'Â£´', 'k': 'Â∞á', 'c': 'Á†≤', 'p': 'Âçí' };

        // ================= D·ªäCH N∆Ø·ªöC C·ªú CHU·∫®N (NOTATION) =================
        function generateNotation(board, fromR, fromC, toR, toC) {
            let p = board[fromR][fromC];
            let isRed = (p === p.toUpperCase());
            let pName = pieceVietName[p];

            let startCol = isRed ? (9 - fromC) : (fromC + 1);
            let endCol = isRed ? (9 - toC) : (toC + 1);

            let piecesOnSameFile = [];
            for (let r = 0; r < 10; r++) { if (board[r][fromC] === p) piecesOnSameFile.push(r); }

            let prefix = pName; let showStartCol = true;

            if (piecesOnSameFile.length === 2) {
                let sorted = piecesOnSameFile.sort((a,b) => a - b); 
                let isFront = isRed ? (fromR === sorted[0]) : (fromR === sorted[1]);
                prefix = isFront ? ("Ti·ªÅn " + pName) : ("H·∫≠u " + pName);
                showStartCol = false; 
            } else if (piecesOnSameFile.length > 2) {
                let sorted = piecesOnSameFile.sort((a,b) => isRed ? a - b : b - a);
                let idx = sorted.indexOf(fromR);
                let names = ["Ti·ªÅn", "Trung", "H·∫≠u", "T·ª©", "Ng≈©"];
                prefix = names[idx] + " " + pName;
                showStartCol = false;
            }

            let action = ""; let target = "";
            if (fromR === toR) {
                action = "b√¨nh"; target = endCol;
            } else {
                let isForward = isRed ? (toR < fromR) : (toR > fromR);
                action = isForward ? "t·∫•n" : "tho√°i";
                let straightMovers = ['R', 'C', 'P', 'K', 'A', 'r', 'c', 'p', 'k', 'a'];
                if (straightMovers.includes(p)) {
                    target = Math.abs(toR - fromR); 
                } else {
                    target = endCol; 
                }
            }
            
            let colorPrefix = isRed ? "ƒê·ªè" : "ƒêen";
            return `${colorPrefix}: ${prefix} ${showStartCol ? startCol : ''} ${action} ${target}`.replace(/\s+/g, ' ').trim();
        }

        function boardToFen(boardArray) {
            let fen = '';
            for (let r = 0; r < 10; r++) {
                let emptyCount = 0;
                for (let c = 0; c < 9; c++) {
                    if (boardArray[r][c] === '.') { emptyCount++; } 
                    else { if (emptyCount > 0) { fen += emptyCount; emptyCount = 0; } fen += boardArray[r][c]; }
                }
                if (emptyCount > 0) fen += emptyCount;
                if (r < 9) fen += '/';
            }
            return fen;
        }

        function fenToBoard(fenStr) {
            let board = []; let rows = fenStr.split('/');
            for (let r = 0; r < 10; r++) {
                let row = [];
                for (let i = 0; i < rows[r].length; i++) {
                    let char = rows[r][i];
                    if (!isNaN(char)) { let count = parseInt(char); for (let j = 0; j < count; j++) row.push('.'); } 
                    else { row.push(char); }
                }
                board.push(row);
            }
            return board;
        }

        let appData = []; let currentBookId = null; 
        let bookTree; let currentNode; let historyPath = []; let selectedSquare = null; let isGameOver = false; 
        let isFlipped = false; let isMirrored = false;
        let currentBoardState = null; 
        let isUnsavedToPhysicalFile = false; let localFileHandle = null; 

        function initApp() {
            let saved = localStorage.getItem('xiangqi_app_v26');
            if (saved) { appData = JSON.parse(saved); convertLegacyBooks(); }
            if ('showSaveFilePicker' in window) { document.getElementById('btn-sync').style.display = 'block'; }
            showDashboard();
        }

        function convertLegacyBooks() {
            let changed = false;
            appData.forEach(book => {
                function walk(node) {
                    if (Array.isArray(node.board)) { node.board = boardToFen(node.board); changed = true; }
                    node.children.forEach(walk);
                }
                walk(book.tree);
            });
            if (changed) saveAppData();
        }

        function saveAppData() { 
            localStorage.setItem('xiangqi_app_v26', JSON.stringify(appData)); 
            isUnsavedToPhysicalFile = true; updateWarningUI();
            if (localFileHandle) syncToLocalFile(); 
        }

        function updateWarningUI() { document.getElementById('unsaved-warning').style.display = (isUnsavedToPhysicalFile && !localFileHandle) ? 'block' : 'none'; }
        window.addEventListener('beforeunload', function (e) { if (isUnsavedToPhysicalFile && !localFileHandle) { e.preventDefault(); e.returnValue = ''; } });

        async function setupAutoSync() {
            try {
                localFileHandle = await window.showSaveFilePicker({ suggestedName: 'ThuVienCoTuong_AutoSave.json', types: [{ description: 'JSON Files', accept: {'application/json': ['.json']} }], });
                let btn = document.getElementById('btn-sync'); btn.innerText = "‚úÖ ƒêANG AUTO-SAVE"; btn.style.background = "#28a745";
                alert("K·∫øt n·ªëi th√†nh c√¥ng! T·ª´ gi·ªù m·ªçi n∆∞·ªõc ƒëi s·∫Ω t·ª± ƒë·ªông l∆∞u th·∫≥ng v√†o file tr√™n m√°y t√≠nh.");
                syncToLocalFile();
            } catch (err) { if(err.name !== 'AbortError') alert("L·ªói: Tr√¨nh duy·ªát kh√¥ng h·ªó tr·ª£ t√≠nh nƒÉng n√†y."); }
        }

        async function syncToLocalFile() {
            if (localFileHandle) {
                try {
                    const writable = await localFileHandle.createWritable();
                    await writable.write(JSON.stringify(appData, null, 2)); await writable.close();
                    isUnsavedToPhysicalFile = false; updateWarningUI();
                } catch (err) { console.error("L·ªói Auto-save:", err); }
            }
        }

        function exportBook(id) {
            let book = appData.find(b => b.id === id); if (!book) return;
            let dataStr = JSON.stringify(book, null, 2); let blob = new Blob([dataStr], { type: "application/json" });
            let url = URL.createObjectURL(blob); let a = document.createElement('a'); a.href = url; a.download = (book.name || "Book") + ".json";
            document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
            isUnsavedToPhysicalFile = false; updateWarningUI();
        }

        function importBook(event) {
            let file = event.target.files[0]; if (!file) return;
            let reader = new FileReader();
            reader.onload = function(e) {
                try {
                    let importedBook = JSON.parse(e.target.result);
                    if (importedBook && importedBook.tree && importedBook.tree.id === 'root') {
                        importedBook.id = 'book_' + Date.now(); importedBook.updatedAt = Date.now();
                        appData.push(importedBook); convertLegacyBooks(); 
                        saveAppData(); renderDashboard(); alert("ƒê√£ nh·∫≠p Book th√†nh c√¥ng!");
                    } else { alert("File kh√¥ng ƒë√∫ng ƒë·ªãnh d·∫°ng!"); }
                } catch(err) { alert("L·ªói ƒë·ªçc file!"); }
                event.target.value = ""; 
            };
            reader.readAsText(file);
        }

        function showDashboard() {
            document.getElementById('dashboard-screen').style.display = 'flex'; document.getElementById('editor-screen').style.display = 'none';
            document.getElementById('btn-back').style.display = 'none'; document.getElementById('header-title').innerText = "S·ªï Tay Khai Cu·ªôc";
            currentBookId = null; renderDashboard(); updateWarningUI();
        }

        function renderDashboard() {
            const container = document.getElementById('book-list-container'); container.innerHTML = '';
            if (appData.length === 0) { container.innerHTML = '<div style="text-align:center; color:#888; margin-top: 30px; font-size: 16px;">B·∫°n ch∆∞a c√≥ Book n√†o.<br><br>H√£y b·∫•m <b>T·∫°o M·ªõi</b> ho·∫∑c <b>M·ªü File</b> ƒë·ªÉ b·∫Øt ƒë·∫ßu nh√©!</div>'; return; }
            let sortedBooks = [...appData].sort((a, b) => b.updatedAt - a.updatedAt);
            sortedBooks.forEach(book => {
                let dateStr = new Date(book.updatedAt).toLocaleString('vi-VN');
                let item = document.createElement('div'); item.className = 'book-item';
                item.innerHTML = `
                    <div class="book-info" onclick="openBook('${book.id}')">
                        <div class="book-title">${book.name}</div>
                        <div class="book-meta">C·∫≠p nh·∫≠t: ${dateStr}</div>
                    </div>
                    <div class="book-actions">
                        <button class="btn-sm btn-export" onclick="exportBook('${book.id}')">‚¨áÔ∏è T·∫£i file</button>
                        <button class="btn-sm btn-edit-name" onclick="renameBook('${book.id}')">‚úèÔ∏è ƒê·ªïi t√™n</button>
                        <button class="btn-sm btn-delete" onclick="deleteBook('${book.id}')">‚ùå X√≥a</button>
                    </div>
                `;
                container.appendChild(item);
            });
        }

        function createNewBook() {
            let name = prompt("Nh·∫≠p t√™n cho Book c·ªù m·ªõi:", "Book Kh√¥ng T√™n");
            if (name && name.trim() !== "") {
                let newBook = { 
                    id: 'book_' + Date.now(), name: name.trim(), updatedAt: Date.now(), 
                    tree: { id: 'root', board: boardToFen(startState), moveName: 'B·∫Øt ƒë·∫ßu', moveDetails: null, note: '', isRedTurn: true, children: [] } 
                };
                appData.push(newBook); saveAppData(); openBook(newBook.id);
            }
        }

        function renameBook(id) {
            let book = appData.find(b => b.id === id); let newName = prompt("S·ª≠a t√™n Book:", book.name);
            if (newName && newName.trim() !== "") { book.name = newName.trim(); book.updatedAt = Date.now(); saveAppData(); renderDashboard(); }
        }
        function deleteBook(id) { if (confirm("B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën x√≥a Book n√†y vƒ©nh vi·ªÖn?")) { appData = appData.filter(b => b.id !== id); saveAppData(); renderDashboard(); } }

        function openBook(id) {
            let book = appData.find(b => b.id === id); currentBookId = book.id; bookTree = book.tree; currentNode = bookTree; historyPath = [bookTree];
            currentBoardState = fenToBoard(currentNode.board); 
            isFlipped = false; isMirrored = false; selectedSquare = null;
            document.getElementById('dashboard-screen').style.display = 'none'; document.getElementById('editor-screen').style.display = 'flex';
            document.getElementById('btn-back').style.display = 'block'; document.getElementById('header-title').innerText = book.name;
            drawBoardLines(); renderBoard();
        }

        function autoSaveBook() { if (currentBookId) { let book = appData.find(b => b.id === currentBookId); book.updatedAt = Date.now(); saveAppData(); } }

        function toggleFlip() { isFlipped = !isFlipped; renderBoard(); }
        function toggleMirror() { isMirrored = !isMirrored; renderBoard(); }

        // ================= ƒê·ªí H·ªåA B√ÄN C·ªú =================
        function drawBoardLines() {
            const svg = document.getElementById('board-svg'); let html = '';
            for(let i=0; i<=9; i++) { let y = i * 100; html += `<line x1="0" y1="${y}" x2="800" y2="${y}" stroke="var(--line-color)" stroke-width="3"/>`; }
            for(let i=0; i<=8; i++) {
                let x = i * 100;
                if(i===0 || i===8) html += `<line x1="${x}" y1="0" x2="${x}" y2="900" stroke="var(--line-color)" stroke-width="3"/>`;
                else { html += `<line x1="${x}" y1="0" x2="${x}" y2="400" stroke="var(--line-color)" stroke-width="3"/>`; html += `<line x1="${x}" y1="500" x2="${x}" y2="900" stroke="var(--line-color)" stroke-width="3"/>`; }
            }
            html += `<line x1="300" y1="0" x2="500" y2="200" stroke="var(--line-color)" stroke-width="3"/>`; html += `<line x1="500" y1="0" x2="300" y2="200" stroke="var(--line-color)" stroke-width="3"/>`;
            html += `<line x1="300" y1="700" x2="500" y2="900" stroke="var(--line-color)" stroke-width="3"/>`; html += `<line x1="500" y1="700" x2="300" y2="900" stroke="var(--line-color)" stroke-width="3"/>`;
            
            // FIX: Hoa Hoa t·ª∑ l·ªá 70%
            function createCross(c, r, drawL, drawR) {
                let x = c * 100; let y = r * 100;
                let gap = 8; let len = 15; let h = ''; // K√≠ch th∆∞·ªõc gi·∫£m g·ªçn l·∫°i
                if(drawL) {
                    h += `<path d="M${x-gap},${y-gap-len} L${x-gap},${y-gap} L${x-gap-len},${y-gap}" fill="none" stroke="var(--line-color)" stroke-width="2"/>`;
                    h += `<path d="M${x-gap},${y+gap+len} L${x-gap},${y+gap} L${x-gap-len},${y+gap}" fill="none" stroke="var(--line-color)" stroke-width="2"/>`;
                }
                if(drawR) {
                    h += `<path d="M${x+gap},${y-gap-len} L${x+gap},${y-gap} L${x+gap+len},${y-gap}" fill="none" stroke="var(--line-color)" stroke-width="2"/>`;
                    h += `<path d="M${x+gap},${y+gap+len} L${x+gap},${y+gap} L${x+gap+len},${y+gap}" fill="none" stroke="var(--line-color)" stroke-width="2"/>`;
                }
                return h;
            }
            
            html += createCross(1, 2, true, true); html += createCross(7, 2, true, true);
            html += createCross(1, 7, true, true); html += createCross(7, 7, true, true);
            html += createCross(0, 3, false, true); html += createCross(2, 3, true, true); html += createCross(4, 3, true, true); html += createCross(6, 3, true, true); html += createCross(8, 3, true, false);
            html += createCross(0, 6, false, true); html += createCross(2, 6, true, true); html += createCross(4, 6, true, true); html += createCross(6, 6, true, true); html += createCross(8, 6, true, false);

            svg.innerHTML = html;
        }

        // T·∫°o s·ªë t·ªça ƒë·ªô cƒÉn l·ªÅ tuy·ªát ƒë·ªëi
        function drawCoordinates() {
            let topStr = ''; let botStr = '';
            for (let c=0; c<=8; c++) {
                let botVal = isFlipped ? (isMirrored ? 9-c : c+1) : (isMirrored ? c+1 : 9-c);
                let topVal = isFlipped ? (isMirrored ? c+1 : 9-c) : (isMirrored ? 9-c : c+1);
                
                let leftPos = (c * 100 / 8) + '%';
                botStr += `<span style="left: ${leftPos}">${botVal}</span>`;
                topStr += `<span style="left: ${leftPos}">${topVal}</span>`;
            }
            document.getElementById('coord-bottom').innerHTML = botStr;
            document.getElementById('coord-top').innerHTML = topStr;
        }

        function drawVariationArrows() {
            const group = document.getElementById('arrows-group'); group.innerHTML = '';
            if (selectedSquare || isGameOver) return; 

            // FIX: ƒê√£ x√≥a n√©t ƒë·ª©t b√°o hi·ªáu l·ªãch s·ª≠ n∆∞·ªõc ƒëi. Ch·ªâ gi·ªØ m≈©i t√™n cho bi·∫øn G·ª£i √Ω nh√°nh.
            currentNode.children.forEach(child => {
                if (child.moveDetails) {
                    let {fromR, fromC, toR, toC} = child.moveDetails;
                    let drawFromR = isFlipped ? 9 - fromR : fromR; let drawFromC = fromC; if (isMirrored) drawFromC = 8 - drawFromC; if (isFlipped) drawFromC = 8 - drawFromC;
                    let drawToR = isFlipped ? 9 - toR : toR; let drawToC = toC; if (isMirrored) drawToC = 8 - drawToC; if (isFlipped) drawToC = 8 - drawToC;

                    let x1 = drawFromC * 100; let y1 = drawFromR * 100;
                    let x2 = drawToC * 100; let y2 = drawToR * 100;
                    
                    let isCapture = currentBoardState[toR][toC] !== '.';
                    let color = isCapture ? '#cc0000' : '#0044cc'; let markerId = isCapture ? 'url(#arrowhead-red)' : 'url(#arrowhead)';
                    let line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', x1); line.setAttribute('y1', y1); line.setAttribute('x2', x2); line.setAttribute('y2', y2);
                    line.setAttribute('stroke', color); line.setAttribute('stroke-width', '4'); line.setAttribute('marker-end', markerId); line.setAttribute('opacity', '0.7');
                    group.appendChild(line);
                }
            });
        }

        function renderBoard() {
            const layer = document.getElementById('pieces-layer'); layer.innerHTML = ''; 
            let isCheck = isUnderCheck(currentBoardState, currentNode.isRedTurn);
            drawCoordinates();

            for (let r = 0; r < 10; r++) {
                for (let c = 0; c < 9; c++) {
                    let point = document.createElement('div'); point.className = 'point'; 
                    let displayR = isFlipped ? 9 - r : r; let displayC = c; if (isMirrored) displayC = 8 - displayC; if (isFlipped) displayC = 8 - displayC;
                    point.style.left = (displayC * 100 / 8) + '%'; point.style.top = (displayR * 100 / 9) + '%';
                    point.onclick = () => handleCellClick(r, c);

                    // FIX: Bi·ªÉu hi·ªán n∆∞·ªõc ƒëi c≈© b·∫±ng ch·∫•m tr√≤n si√™u nh·ªè
                    if (currentNode.moveDetails && !selectedSquare) {
                        let lm = currentNode.moveDetails;
                        if ((r === lm.fromR && c === lm.fromC) || (r === lm.toR && c === lm.toC)) {
                            let dot = document.createElement('div'); dot.className = 'last-move-dot'; point.appendChild(dot);
                        }
                    }

                    let pieceChar = currentBoardState[r][c];
                    
                    if (pieceChar !== '.') {
                        let piece = document.createElement('div');
                        let isRed = pieceChar === pieceChar.toUpperCase();
                        piece.className = 'piece ' + (isRed ? 'red-piece' : 'black-piece');
                        
                        // FIX: Vi·ªÅn s√°ng nh·∫°t (70%) cho qu√¢n c·ªù v·ª´a m·ªõi t·ªõi ƒë√≠ch
                        if (currentNode.moveDetails && !selectedSquare && r === currentNode.moveDetails.toR && c === currentNode.moveDetails.toC) {
                            piece.classList.add('last-moved-piece');
                        }

                        if (selectedSquare && selectedSquare.r === r && selectedSquare.c === c) piece.classList.add('selected');
                        if (isCheck && ((isRed && currentNode.isRedTurn && pieceChar==='K') || (!isRed && !currentNode.isRedTurn && pieceChar==='k'))) piece.classList.add('in-check-piece');
                        piece.innerText = pieceMap[pieceChar]; point.appendChild(piece);
                    } 
                    
                    if (selectedSquare && !isGameOver) {
                        if(checkMoveLogic(currentBoardState, selectedSquare.r, selectedSquare.c, r, c)) {
                            if (currentBoardState[r][c] !== '.') { let hint = document.createElement('div'); hint.className = 'capture-hint'; point.appendChild(hint); } 
                            else { let hint = document.createElement('div'); hint.className = 'valid-move-hint'; point.appendChild(hint); }
                        }
                    }

                    if (!selectedSquare && !isGameOver) {
                        currentNode.children.forEach((child, index) => {
                            if (child.moveDetails && child.moveDetails.toR === r && child.moveDetails.toC === c) {
                                if (currentNode.children.length >= 2) {
                                    let isCapture = currentBoardState[r][c] !== '.'; let marker = document.createElement('div'); marker.className = 'var-marker';
                                    marker.style.backgroundColor = isCapture ? '#cc0000' : '#0044cc'; marker.innerText = index + 1; point.appendChild(marker);
                                }
                                point.onclick = (e) => { e.stopPropagation(); selectedSquare = null; goToNode(child); };
                            }
                        });
                    }
                    layer.appendChild(point);
                }
            }
            drawVariationArrows(); updateUI(isCheck);
        }

        function updateUI(isCheck) {
            const turnInd = document.getElementById('turn-indicator');
            let canMove = hasAnyLegalMove(currentBoardState, currentNode.isRedTurn); isGameOver = false;
            if (!canMove) { isGameOver = true; if (isCheck) { turnInd.innerText = (currentNode.isRedTurn ? "ƒê·ªé" : "ƒêEN") + " B·ªä CHI·∫æU H·∫æT (MATE)!"; turnInd.className = "mate-alert"; } else { turnInd.innerText = (currentNode.isRedTurn ? "ƒê·ªé" : "ƒêEN") + " H·∫æT N∆Ø·ªöC ƒêI (H√íA)!"; turnInd.className = "mate-alert"; }
            } else if (isCheck) { turnInd.innerText = (currentNode.isRedTurn ? "üî¥ ƒê·ªé" : "‚ö´ ƒêEN") + " ƒêANG B·ªä CHI·∫æU!"; turnInd.className = "check-alert"; } 
            else { turnInd.innerText = currentNode.isRedTurn ? "üî¥ L∆∞·ª£t ƒëi: ƒê·ªé" : "‚ö´ L∆∞·ª£t ƒëi: ƒêEN"; turnInd.className = currentNode.isRedTurn ? "red-turn" : "black-turn"; }

            document.getElementById('move-info').innerText = currentNode.moveName;

            let noteContent = document.getElementById('note-content');
            if (currentNode.note && currentNode.note.trim() !== '') { noteContent.innerHTML = currentNode.note.replace(/\n/g, '<br>'); noteContent.style.color = '#111'; noteContent.style.fontStyle = 'normal';
            } else { noteContent.innerText = 'Ch∆∞a c√≥ ghi ch√∫ cho th·∫ø c·ªù n√†y.'; noteContent.style.color = '#888'; noteContent.style.fontStyle = 'italic'; }
            document.getElementById('note-view').style.display = 'flex'; document.getElementById('note-edit').style.display = 'none';

            const varContainer = document.getElementById('variations'); varContainer.innerHTML = '';
            
            if (currentNode.children.length > 0) {
                varContainer.style.display = 'flex'; 
                
                currentNode.children.forEach((childNode, index) => {
                    let group = document.createElement('div'); group.className = 'var-btn-group';
                    let btn = document.createElement('button'); btn.className = 'var-btn';
                    let delBtn = document.createElement('button'); delBtn.className = 'var-delete-btn'; delBtn.innerHTML = '‚úñ'; delBtn.title = "X√≥a nh√°nh n√†y";

                    let isCapture = currentBoardState[childNode.moveDetails.toR][childNode.moveDetails.toC] !== '.';
                    if (isCapture) { group.classList.add('capture-group'); btn.classList.add('capture-btn'); delBtn.classList.add('capture-del'); } 
                    
                    let shortName = childNode.moveName.split(':')[1].trim();
                    btn.innerText = currentNode.children.length >= 2 ? `[${index + 1}] ${shortName}` : shortName;
                    
                    btn.onclick = () => { selectedSquare = null; goToNode(childNode); };
                    delBtn.onclick = (e) => {
                        e.stopPropagation();
                        if(confirm(`‚ö†Ô∏è C·∫¢NH B√ÅO: B·∫°n c√≥ ch·∫Øc mu·ªën X√ìA Vƒ®NH VI·ªÑN nh√°nh [${shortName}] kh√¥ng?`)) {
                            currentNode.children.splice(index, 1); autoSaveBook(); selectedSquare = null; renderBoard();
                        }
                    };
                    group.appendChild(btn); group.appendChild(delBtn); varContainer.appendChild(group);
                });
            } else {
                varContainer.style.display = 'none'; 
            }
        }

        function enableEditNote() { document.getElementById('note-view').style.display = 'none'; document.getElementById('note-edit').style.display = 'flex'; document.getElementById('note-input').value = currentNode.note || ''; document.getElementById('note-input').focus(); }
        function cancelEditNote() { document.getElementById('note-view').style.display = 'flex'; document.getElementById('note-edit').style.display = 'none'; }
        function saveNote() { currentNode.note = document.getElementById('note-input').value; autoSaveBook(); updateUI(isUnderCheck(currentBoardState, currentNode.isRedTurn)); }

        function goToNode(node) { historyPath.push(node); currentNode = node; currentBoardState = fenToBoard(currentNode.board); renderBoard(); }
        function goBackToBranch() { if (historyPath.length <= 1) return; historyPath.pop(); while (historyPath.length > 1) { let topNode = historyPath[historyPath.length - 1]; if (topNode.children.length >= 2) break; historyPath.pop(); } currentNode = historyPath[historyPath.length - 1]; currentBoardState = fenToBoard(currentNode.board); selectedSquare = null; renderBoard(); }
        function goNext() { if (currentNode.children.length === 1) { selectedSquare = null; goToNode(currentNode.children[0]); } else if (currentNode.children.length > 1) { const varDiv = document.getElementById('variations'); varDiv.style.backgroundColor = '#ffffcc'; setTimeout(() => varDiv.style.backgroundColor = 'transparent', 300); } }
        function goBack() { if (historyPath.length > 1) { historyPath.pop(); currentNode = historyPath[historyPath.length - 1]; currentBoardState = fenToBoard(currentNode.board); selectedSquare = null; renderBoard(); } }
        function resetToRoot() { historyPath = [bookTree]; currentNode = bookTree; currentBoardState = fenToBoard(currentNode.board); selectedSquare = null; renderBoard(); }

        function rawMoveLogic(board, r1, c1, r2, c2) {
            let p = board[r1][c1]; let isRed = (p === p.toUpperCase()); let target = board[r2][c2];
            if (target !== '.' && (target === target.toUpperCase()) === isRed) return false;
            let dr = r2 - r1; let absDr = Math.abs(dr); let dc = c2 - c1; let absDc = Math.abs(dc);
            switch(p.toLowerCase()) {
                case 'k': if (c2 < 3 || c2 > 5) return false; if (isRed && r2 < 7) return false; if (!isRed && r2 > 2) return false; if (absDr + absDc !== 1) return false; break;
                case 'a': if (c2 < 3 || c2 > 5) return false; if (isRed && r2 < 7) return false; if (!isRed && r2 > 2) return false; if (absDr !== 1 || absDc !== 1) return false; break;
                case 'e': if (isRed && r2 < 5) return false; if (!isRed && r2 > 4) return false; if (absDr !== 2 || absDc !== 2) return false; if (board[r1 + dr/2][c1 + dc/2] !== '.') return false; break;
                case 'h': if (!((absDr === 2 && absDc === 1) || (absDr === 1 && absDc === 2))) return false; if (absDr === 2 && board[r1 + dr/2][c1] !== '.') return false; if (absDc === 2 && board[r1][c1 + dc/2] !== '.') return false; break;
                case 'r': if (dr !== 0 && dc !== 0) return false; if (countPiecesBetween(board, r1, c1, r2, c2) !== 0) return false; break;
                case 'c': if (dr !== 0 && dc !== 0) return false; let piecesBetween = countPiecesBetween(board, r1, c1, r2, c2); if (target === '.') { if(piecesBetween !== 0) return false; } else { if(piecesBetween !== 1) return false; } break;
                case 'p': if (isRed) { if (dr >= 0) return false; if (r1 >= 5 && absDc !== 0) return false; } else { if (dr <= 0) return false; if (r1 <= 4 && absDc !== 0) return false; } if (absDr + absDc !== 1) return false; break;
            } return true;
        }

        function isUnderCheck(board, isRed) {
            let kingR, kingC; let kingChar = isRed ? 'K' : 'k';
            for(let r=0; r<10; r++) for(let c=0; c<9; c++) if(board[r][c] === kingChar) { kingR = r; kingC = c; break; }
            if(kingR === undefined) return false;
            for(let r=0; r<10; r++) { for(let c=0; c<9; c++) { let p = board[r][c]; if(p !== '.' && (p === p.toUpperCase()) !== isRed) { if(rawMoveLogic(board, r, c, kingR, kingC)) return true; } } }
            return false;
        }
        function isKingsFacing(board) {
            let redK = null, blackK = null;
            for (let r = 0; r < 10; r++) { for (let c = 3; c <= 5; c++) { if (board[r][c] === 'K') redK = {r, c}; if (board[r][c] === 'k') blackK = {r, c}; } }
            if (redK && blackK && redK.c === blackK.c) { if (countPiecesBetween(board, blackK.r, blackK.c, redK.r, redK.c) === 0) return true; } return false;
        }
        function checkMoveLogic(board, r1, c1, r2, c2) {
            let p = board[r1][c1]; let isRed = (p === p.toUpperCase());
            if (!rawMoveLogic(board, r1, c1, r2, c2)) return false;
            let tempBoard = JSON.parse(JSON.stringify(board)); tempBoard[r2][c2] = p; tempBoard[r1][c1] = '.';
            if (isKingsFacing(tempBoard)) return false; if (isUnderCheck(tempBoard, isRed)) return false; return true;
        }
        function hasAnyLegalMove(board, isRed) {
            for(let r1=0; r1<10; r1++) { for(let c1=0; c1<9; c1++) { let p = board[r1][c1]; if(p !== '.' && (p === p.toUpperCase()) === isRed) { for(let r2=0; r2<10; r2++) { for(let c2=0; c2<9; c2++) { if(checkMoveLogic(board, r1, c1, r2, c2)) return true; } } } } } return false;
        }
        function countPiecesBetween(board, r1, c1, r2, c2) {
            let count = 0;
            if (r1 === r2) { let min = Math.min(c1, c2), max = Math.max(c1, c2); for (let c = min + 1; c < max; c++) if (board[r1][c] !== '.') count++; } 
            else { let min = Math.min(r1, r2), max = Math.max(r1, r2); for (let r = min + 1; r < max; r++) if (board[r][c1] !== '.') count++; } return count;
        }

        function handleCellClick(r, c) {
            if (isGameOver) return; let clickedPiece = currentBoardState[r][c];
            if (!selectedSquare) {
                if (clickedPiece !== '.') {
                    let isRedPiece = clickedPiece === clickedPiece.toUpperCase();
                    if (isRedPiece !== currentNode.isRedTurn) { alert(currentNode.isRedTurn ? "ƒêang l√† l∆∞·ª£t c·ªßa ƒê·ªé!" : "ƒêang l√† l∆∞·ª£t c·ªßa ƒêEN!"); return; }
                    selectedSquare = { r, c }; renderBoard();
                }
            } else {
                if (selectedSquare.r === r && selectedSquare.c === c) { selectedSquare = null; renderBoard(); } 
                else {
                    if (checkMoveLogic(currentBoardState, selectedSquare.r, selectedSquare.c, r, c)) { executeMove(selectedSquare.r, selectedSquare.c, r, c); } 
                    else {
                        let isRedPiece = clickedPiece === clickedPiece.toUpperCase();
                        if (clickedPiece !== '.' && isRedPiece === currentNode.isRedTurn) { selectedSquare = { r, c }; renderBoard(); } 
                    }
                }
            }
        }

        function executeMove(fromR, fromC, toR, toC) {
            let moveName = generateNotation(currentBoardState, fromR, fromC, toR, toC);
            let existingChild = currentNode.children.find(child => child.moveDetails && child.moveDetails.fromR === fromR && child.moveDetails.fromC === fromC && child.moveDetails.toR === toR && child.moveDetails.toC === toC);
            
            selectedSquare = null; 
            if (existingChild) { goToNode(existingChild); } 
            else {
                let movingPiece = currentBoardState[fromR][fromC]; 
                let newBoardState = JSON.parse(JSON.stringify(currentBoardState)); newBoardState[toR][toC] = movingPiece; newBoardState[fromR][fromC] = '.';
                let newNode = { 
                    id: 'node_' + Date.now(), board: boardToFen(newBoardState),
                    moveName: moveName, moveDetails: { fromR, fromC, toR, toC }, note: '', isRedTurn: !currentNode.isRedTurn, children: [] 
                };
                currentNode.children.push(newNode); autoSaveBook(); goToNode(newNode);
            }
        }

        document.addEventListener('keydown', function(e) {
            if (document.getElementById('dashboard-screen').style.display !== 'none') return;
            if (document.activeElement.tagName === 'TEXTAREA' || document.activeElement.tagName === 'INPUT') return;
            if (e.key === 'ArrowLeft') { e.preventDefault(); goBack(); }
            if (e.key === 'ArrowRight') { e.preventDefault(); goNext(); }
            if (e.key === 'ArrowUp') { e.preventDefault(); resetToRoot(); }
        });

        initApp();
    </script>
</body>
</html>


